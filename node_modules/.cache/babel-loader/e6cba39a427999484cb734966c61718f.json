{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safer-buffer').Buffer; // == UTF32-LE/BE codec. ==========================================================\n\n\nexports._utf32 = Utf32Codec;\n\nfunction Utf32Codec(codecOptions, iconv) {\n  this.iconv = iconv;\n  this.bomAware = true;\n  this.isLE = codecOptions.isLE;\n}\n\nexports.utf32le = {\n  type: '_utf32',\n  isLE: true\n};\nexports.utf32be = {\n  type: '_utf32',\n  isLE: false\n}; // Aliases\n\nexports.ucs4le = 'utf32le';\nexports.ucs4be = 'utf32be';\nUtf32Codec.prototype.encoder = Utf32Encoder;\nUtf32Codec.prototype.decoder = Utf32Decoder; // -- Encoding\n\nfunction Utf32Encoder(options, codec) {\n  this.isLE = codec.isLE;\n  this.highSurrogate = 0;\n}\n\nUtf32Encoder.prototype.write = function (str) {\n  var src = Buffer.from(str, 'ucs2');\n  var dst = Buffer.alloc(src.length * 2);\n  var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;\n  var offset = 0;\n\n  for (var i = 0; i < src.length; i += 2) {\n    var code = src.readUInt16LE(i);\n    var isHighSurrogate = 0xD800 <= code && code < 0xDC00;\n    var isLowSurrogate = 0xDC00 <= code && code < 0xE000;\n\n    if (this.highSurrogate) {\n      if (isHighSurrogate || !isLowSurrogate) {\n        // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low\n        // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character\n        // (technically wrong, but expected by some applications, like Windows file names).\n        write32.call(dst, this.highSurrogate, offset);\n        offset += 4;\n      } else {\n        // Create 32-bit value from high and low surrogates;\n        var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;\n        write32.call(dst, codepoint, offset);\n        offset += 4;\n        this.highSurrogate = 0;\n        continue;\n      }\n    }\n\n    if (isHighSurrogate) this.highSurrogate = code;else {\n      // Even if the current character is a low surrogate, with no previous high surrogate, we'll\n      // encode it as a semi-invalid stand-alone character for the same reasons expressed above for\n      // unpaired high surrogates.\n      write32.call(dst, code, offset);\n      offset += 4;\n      this.highSurrogate = 0;\n    }\n  }\n\n  if (offset < dst.length) dst = dst.slice(0, offset);\n  return dst;\n};\n\nUtf32Encoder.prototype.end = function () {\n  // Treat any leftover high surrogate as a semi-valid independent character.\n  if (!this.highSurrogate) return;\n  var buf = Buffer.alloc(4);\n  if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);else buf.writeUInt32BE(this.highSurrogate, 0);\n  this.highSurrogate = 0;\n  return buf;\n}; // -- Decoding\n\n\nfunction Utf32Decoder(options, codec) {\n  this.isLE = codec.isLE;\n  this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);\n  this.overflow = [];\n}\n\nUtf32Decoder.prototype.write = function (src) {\n  if (src.length === 0) return '';\n  var i = 0;\n  var codepoint = 0;\n  var dst = Buffer.alloc(src.length + 4);\n  var offset = 0;\n  var isLE = this.isLE;\n  var overflow = this.overflow;\n  var badChar = this.badChar;\n\n  if (overflow.length > 0) {\n    for (; i < src.length && overflow.length < 4; i++) {\n      overflow.push(src[i]);\n    }\n\n    if (overflow.length === 4) {\n      // NOTE: codepoint is a signed int32 and can be negative.\n      // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).\n      if (isLE) {\n        codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;\n      } else {\n        codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;\n      }\n\n      overflow.length = 0;\n      offset = _writeCodepoint(dst, offset, codepoint, badChar);\n    }\n  } // Main loop. Should be as optimized as possible.\n\n\n  for (; i < src.length - 3; i += 4) {\n    // NOTE: codepoint is a signed int32 and can be negative.\n    if (isLE) {\n      codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;\n    } else {\n      codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;\n    }\n\n    offset = _writeCodepoint(dst, offset, codepoint, badChar);\n  } // Keep overflowing bytes.\n\n\n  for (; i < src.length; i++) {\n    overflow.push(src[i]);\n  }\n\n  return dst.slice(0, offset).toString('ucs2');\n};\n\nfunction _writeCodepoint(dst, offset, codepoint, badChar) {\n  // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.\n  if (codepoint < 0 || codepoint > 0x10FFFF) {\n    // Not a valid Unicode codepoint\n    codepoint = badChar;\n  } // Ephemeral Planes: Write high surrogate.\n\n\n  if (codepoint >= 0x10000) {\n    codepoint -= 0x10000;\n    var high = 0xD800 | codepoint >> 10;\n    dst[offset++] = high & 0xff;\n    dst[offset++] = high >> 8; // Low surrogate is written below.\n\n    var codepoint = 0xDC00 | codepoint & 0x3FF;\n  } // Write BMP char or low surrogate.\n\n\n  dst[offset++] = codepoint & 0xff;\n  dst[offset++] = codepoint >> 8;\n  return offset;\n}\n\n;\n\nUtf32Decoder.prototype.end = function () {\n  this.overflow.length = 0;\n}; // == UTF-32 Auto codec =============================================================\n// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.\n// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32\n// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});\n// Encoder prepends BOM (which can be overridden with (addBOM: false}).\n\n\nexports.utf32 = Utf32AutoCodec;\nexports.ucs4 = 'utf32';\n\nfunction Utf32AutoCodec(options, iconv) {\n  this.iconv = iconv;\n}\n\nUtf32AutoCodec.prototype.encoder = Utf32AutoEncoder;\nUtf32AutoCodec.prototype.decoder = Utf32AutoDecoder; // -- Encoding\n\nfunction Utf32AutoEncoder(options, codec) {\n  options = options || {};\n  if (options.addBOM === undefined) options.addBOM = true;\n  this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);\n}\n\nUtf32AutoEncoder.prototype.write = function (str) {\n  return this.encoder.write(str);\n};\n\nUtf32AutoEncoder.prototype.end = function () {\n  return this.encoder.end();\n}; // -- Decoding\n\n\nfunction Utf32AutoDecoder(options, codec) {\n  this.decoder = null;\n  this.initialBufs = [];\n  this.initialBufsLen = 0;\n  this.options = options || {};\n  this.iconv = codec.iconv;\n}\n\nUtf32AutoDecoder.prototype.write = function (buf) {\n  if (!this.decoder) {\n    // Codec is not chosen yet. Accumulate initial bytes.\n    this.initialBufs.push(buf);\n    this.initialBufsLen += buf.length;\n    if (this.initialBufsLen < 32) // We need more bytes to use space heuristic (see below)\n      return ''; // We have enough bytes -> detect endianness.\n\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    var resStr = '';\n\n    for (var i = 0; i < this.initialBufs.length; i++) {\n      resStr += this.decoder.write(this.initialBufs[i]);\n    }\n\n    this.initialBufs.length = this.initialBufsLen = 0;\n    return resStr;\n  }\n\n  return this.decoder.write(buf);\n};\n\nUtf32AutoDecoder.prototype.end = function () {\n  if (!this.decoder) {\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    var resStr = '';\n\n    for (var i = 0; i < this.initialBufs.length; i++) {\n      resStr += this.decoder.write(this.initialBufs[i]);\n    }\n\n    var trail = this.decoder.end();\n    if (trail) resStr += trail;\n    this.initialBufs.length = this.initialBufsLen = 0;\n    return resStr;\n  }\n\n  return this.decoder.end();\n};\n\nfunction detectEncoding(bufs, defaultEncoding) {\n  var b = [];\n  var charsProcessed = 0;\n  var invalidLE = 0,\n      invalidBE = 0; // Number of invalid chars when decoded as LE or BE.\n\n  var bmpCharsLE = 0,\n      bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.\n\n  outer_loop: for (var i = 0; i < bufs.length; i++) {\n    var buf = bufs[i];\n\n    for (var j = 0; j < buf.length; j++) {\n      b.push(buf[j]);\n\n      if (b.length === 4) {\n        if (charsProcessed === 0) {\n          // Check BOM first.\n          if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {\n            return 'utf-32le';\n          }\n\n          if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {\n            return 'utf-32be';\n          }\n        }\n\n        if (b[0] !== 0 || b[1] > 0x10) invalidBE++;\n        if (b[3] !== 0 || b[2] > 0x10) invalidLE++;\n        if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;\n        if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;\n        b.length = 0;\n        charsProcessed++;\n\n        if (charsProcessed >= 100) {\n          break outer_loop;\n        }\n      }\n    }\n  } // Make decisions.\n\n\n  if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return 'utf-32be';\n  if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return 'utf-32le'; // Couldn't decide (likely all zeros or not enough data).\n\n  return defaultEncoding || 'utf-32le';\n}","map":null,"metadata":{},"sourceType":"script"}